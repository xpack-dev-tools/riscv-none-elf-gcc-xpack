
{/* ------------------------------------------------------------------------ */}

<details>
<summary>Why do I get _unrecognized opcode `csrr`_?</summary>

Starting with GCC 12.x, the compiler
implements the new RISC-V ISA, which introduces an incompatibility issue

The solution is to add `_zicsr` and/or `_zifencei` to the
`-march` option, e.g. `-march=rv32imac` becomes
`-march=rv32imac_zicsr_zifencei`.
</details>

<details>
<summary>There are two RISC-V toolchains, `riscv64-unknown-elf-gcc` and
`riscv32-unknown-elf-gcc` (or `riscv64-none-elf-gcc` and
`riscv32-none-elf-gcc`); you have only one. How can you generate
32 and 64-bit code?</summary>

All RISC-V GCC toolchains, if built correctly, are able to generate
both 32/64-bit code, based on `-march` and `-mabi`. Thus a single
version is enough for all use cases.
</details>

<details>
<summary>Why `riscv-none-elf-gcc` and not `riscv-none-eabi-gcc`, as Arm uses?</summary>

For the moment RISC-V does not define an EABI (Embedded ABI) and uses the
same Unix ABI for embedded applications too, thus `-eabi-` would not be
accurate.
</details>
